Index: linux-4.4.60/drivers/Makefile
===================================================================
--- linux-4.4.60.orig/drivers/Makefile
+++ linux-4.4.60/drivers/Makefile
@@ -172,3 +172,4 @@ obj-$(CONFIG_STM)		+= hwtracing/stm/
 obj-$(CONFIG_ANDROID)		+= android/
 obj-$(CONFIG_NVMEM)		+= nvmem/
 obj-$(CONFIG_FPGA)		+= fpga/
+obj-y				+= miwifi/
Index: linux-4.4.60/drivers/miwifi/Makefile
===================================================================
--- /dev/null
+++ linux-4.4.60/drivers/miwifi/Makefile
@@ -0,0 +1 @@
+obj-y += $(patsubst %.c, %.o, $(notdir $(wildcard $(src)/*.c)))
Index: linux-4.4.60/drivers/miwifi/nvram.c
===================================================================
--- /dev/null
+++ linux-4.4.60/drivers/miwifi/nvram.c
@@ -0,0 +1,768 @@
+/*
+ * This NVRAM module provides cached access to U-Boot environment variables,
+ * in a manner similar to Broadcom's nvram.
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <asm/uaccess.h>
+#include <linux/mtd/mtd.h>
+#include <linux/completion.h>
+
+#include "nvram.h"
+
+static int init_nvram_block(int index);
+static int nvram_close(int index);
+const char *nvram_get(int index, char *name);
+int nvram_set(int index, char *name, char *value);
+int nvram_unset(int index, char *name);
+int nvram_commit(int index);
+int nvram_getall(int index, char *buf);
+int nvram_clear(int index);
+int nvram_sync(int index1, int index2);
+int nvram_reload(int index);
+
+static int nvram_major = -1;
+char nvram_debug = 0;
+
+static DEFINE_MUTEX(nvram_sem);
+
+static struct class *nvram_class = NULL;
+
+/*
+ * Since the write_skip_bad method treat offset differently from u-boot,
+ * the offset of environment variable block must be aligned to erase block size.
+ */
+static block_t fb[FLASH_BLOCK_NUM] = {
+	{
+		.name = "uboot",
+		.mtd_name = NVRAM_MTDNAME,
+		.mtd_dev = NULL,
+		.flash_offset = 0,
+		.flash_max_len = UBOOT_ENV_SIZE,
+		.valid = 0,
+	},
+	{
+		.name = "bdata",
+		.mtd_name = BDATA_MTDNAME,
+		.mtd_dev = NULL,
+		.flash_offset = 0,
+		.flash_max_len = UBOOT_ENV_SIZE,
+		.valid = 0,
+	}
+};
+
+/* ========================================================================
+ * Table of CRC-32's of all single-byte values (made by make_crc_table)
+ */
+const uint32_t crc_table[256] = {
+  0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
+  0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
+  0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
+  0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
+  0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
+  0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
+  0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
+  0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
+  0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
+  0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
+  0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
+  0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
+  0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
+  0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
+  0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
+  0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
+  0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
+  0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
+  0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
+  0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
+  0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
+  0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
+  0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
+  0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
+  0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
+  0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
+  0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
+  0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
+  0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
+  0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
+  0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
+  0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
+  0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
+  0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
+  0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
+  0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
+  0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
+  0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
+  0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
+  0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
+  0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
+  0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
+  0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
+  0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
+  0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
+  0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
+  0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
+  0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
+  0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
+  0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
+  0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
+  0x2d02ef8dL
+};
+
+/* ========================================================================= */
+#define DO1(buf)	crc = crc_table[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);
+#define DO2(buf)	DO1(buf); DO1(buf);
+#define DO4(buf)	DO2(buf); DO2(buf);
+#define DO8(buf)	DO4(buf); DO4(buf);
+
+/* ========================================================================= */
+uint32_t nv_crc32(uint32_t crc, const char *buf, uint32_t len)
+{
+	if (buf == 0)
+		return 0L;
+	crc = crc ^ 0xffffffffL;
+	while (len >= 8) {
+		DO8(buf);
+		len -= 8;
+	}
+	if (len) do {
+		DO1(buf);
+	} while (--len);
+	return crc ^ 0xffffffffL;
+}
+
+int nvram_open(struct inode *inode, struct file *file)
+{
+	try_module_get(THIS_MODULE);
+	return 0;
+}
+
+int nvram_release(struct inode *inode, struct file *file)
+{
+	module_put(THIS_MODULE);
+	return 0;
+}
+
+long nvram_ioctl(struct file *file, unsigned int req,
+		unsigned long arg)
+{
+	int index, len;
+	const char *p;
+	nvram_ioctl_t *nvr;
+	char *value;
+
+	NV_PRINT("--> nvram_ioctl enter\n");
+	switch (req) {
+	case NVRAM_IOCTL_GET:
+		nvr = (nvram_ioctl_t __user *)arg;
+		p = nvram_get(nvr->index, nvr->name);
+		if (p == NULL)
+			p = "";
+
+		if (copy_to_user(nvr->value, p, strlen(p) + 1))
+			return -EFAULT;
+		break;
+	case NVRAM_IOCTL_GETALL:
+		nvr = (nvram_ioctl_t __user *)arg;
+		index = nvr->index;
+		if (fb[index].env == NULL)
+			return -EFAULT;
+		len = fb[index].flash_max_len - sizeof(fb[index].env->crc);
+
+		if (nvram_getall(index, fb[index].env->data) == 0) {
+			if (copy_to_user(nvr->value, fb[index].env->data, len))
+				return -EFAULT;
+		}
+		break;
+	case NVRAM_IOCTL_SET:
+		nvr = (nvram_ioctl_t *)arg;
+		value = (char *)kmalloc(MAX_VALUE_LEN, GFP_KERNEL);
+		if (!value)
+			return -ENOMEM;
+
+		if (copy_from_user(value, nvr->value, strlen(nvr->value) + 1)) {
+			kfree(value);
+			return -EFAULT;
+		}
+
+		nvram_set(nvr->index, nvr->name, value);
+		kfree(value);
+		break;
+
+	case NVRAM_IOCTL_COMMIT:
+		nvr = (nvram_ioctl_t __user *)arg;
+		nvram_commit(nvr->index);
+		break;
+	case NVRAM_IOCTL_CLEAR:
+		nvr = (nvram_ioctl_t __user *)arg;
+		nvram_clear(nvr->index);
+		break;
+	case NVRAM_IOCTL_SYNC:
+		nvr = (nvram_ioctl_t __user *)arg;
+		nvram_sync(nvr->index, nvr->ret);
+		break;
+	case NVRAM_IOCTL_UNSET:
+		nvr = (nvram_ioctl_t __user *)arg;
+		nvram_unset(nvr->index, nvr->name);
+		break;
+	case NVRAM_IOCTL_RELOAD:
+		nvr = (nvram_ioctl_t __user *)arg;
+		nvram_reload(nvr->index);
+		break;
+
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+struct file_operations nvram_fops = {
+	.owner = THIS_MODULE,
+	.unlocked_ioctl = nvram_ioctl,
+	.open = nvram_open,
+	.release = nvram_release,
+};
+
+int __init nvram_init(void)
+{
+	int i;
+
+	nvram_major = register_chrdev(0, NVRAM_DEVNAME, &nvram_fops);
+	if (nvram_major < 0) {
+		printk(KERN_ERR "nvram: unable to register character device\n");
+		return nvram_major;
+	}
+	/* Create /dev/nvram handle */
+	nvram_class = class_create(THIS_MODULE, "nvram");
+	if (IS_ERR(nvram_class)) {
+		printk("Error creating nvram class\n");
+		return -EIO;
+	}
+
+	/* Add the device nvram0 */
+	device_create(nvram_class, NULL, MKDEV(nvram_major, 0), NULL, "nvram");
+
+	mutex_lock(&nvram_sem);
+	for (i = 0; i < FLASH_BLOCK_NUM; i++)
+		init_nvram_block(i);
+	mutex_unlock(&nvram_sem);
+
+	return 0;
+}
+
+static int init_nvram_block(int index)
+{
+	loff_t from;
+	size_t len, rlen;
+	int j, ret;
+	char *p, *q;
+	struct mtd_info *mtd;
+
+	NV_PRINT("--> nvram_init %d\n", index);
+	NV_CHECK_INDEX(-1);
+
+	if (fb[index].valid)
+		return -EINVAL;
+
+	mtd = get_mtd_device_nm(fb[index].mtd_name);
+	if (IS_ERR_OR_NULL(mtd)) {
+		NV_ERROR("Unable to find mtd device %s for nvram block %d\n",
+			fb[index].name, index);
+		return -ENODEV;
+	}
+
+	fb[index].mtd_dev = mtd;
+
+	len = fb[index].flash_max_len;
+	fb[index].env = kmalloc(len, GFP_KERNEL);
+	if (!fb[index].env)
+		return -ENOMEM;
+
+	/* Read crc and data from flash */
+	from = fb[index].flash_offset;
+	ret = mtd_read_skip_bad(mtd, from, len, &rlen, (unsigned char *)fb[index].env);
+	if (ret || (rlen != len)) {
+		NV_ERROR("Failed to read env block %d\n", index);
+		pr_info("from:%llx len:%zx rlen:%zx\n", from, len, rlen);
+		return -EIO;
+	}
+
+	/* Check crc */
+	if (nv_crc32(0, fb[index].env->data, len - sizeof(fb[index].env->crc)) != fb[index].env->crc) {
+		NV_ERROR("Bad CRC %x, ignore values in env block %d\n",
+			(unsigned int)fb[index].env->crc, index);
+		memset(fb[index].env->data, 0, len);
+		//kfree(fb[index].env.data);
+		fb[index].valid = 1;
+		fb[index].dirty = 0;
+		return -1;
+	}
+
+	/* Parse env to cache */
+	p = fb[index].env->data;
+	for (j = 0; j < MAX_CACHE_ENTRY; j++) {
+		if (NULL == (q = strchr(p, '='))) {
+			NV_ERROR("parsed failed - cannot find '='\n");
+			break;
+		}
+		*q = '\0'; //strip '='
+		fb[index].cache[j].name = kstrdup(p, GFP_KERNEL);
+		//printk("  %d '%s'->", i, p);
+
+		p = q + 1; //value
+		if (NULL == (q = strchr(p, '\0'))) {
+			NV_ERROR("parsed failed - cannot find '\\0'\n");
+			break;
+		}
+		fb[index].cache[j].value = kstrdup(p, GFP_KERNEL);
+		//printk("'%s'\n", p);
+
+		p = q + 1; //next entry
+		if (p - fb[index].env->data + 1 >= len) {
+			//end of block
+			break;
+		}
+		if (*p == '\0') {
+			//end of env
+			break;
+		}
+	}
+	if (j == MAX_CACHE_ENTRY)
+		NV_ERROR("Run out of env cache, please increase MAX_CACHE_ENTRY\n");
+
+	fb[index].valid = 1;
+	fb[index].dirty = 0;
+
+	return 0;
+}
+
+static void nvram_exit(void)
+{
+	int index;
+
+	for (index = 0; index < FLASH_BLOCK_NUM; index++) {
+		if (fb[index].dirty)
+			nvram_commit(index);
+
+		nvram_close(index);
+
+		fb[index].valid = 0;
+		//free env
+		kfree(fb[index].env);
+		if (fb[index].mtd_dev)
+			put_mtd_device(fb[index].mtd_dev);
+	}
+
+	if (nvram_class) {
+		device_destroy(nvram_class, MKDEV(nvram_major, 0));
+		class_destroy(nvram_class);
+	}
+
+	unregister_chrdev(nvram_major, NVRAM_DEVNAME);
+}
+
+static int nvram_close(int index)
+{
+	int i;
+
+	NV_PRINT("--> nvram_close %d\n", index);
+	NV_CHECK_INDEX(-1);
+
+	if (!fb[index].valid)
+		return 0;
+	mutex_lock(&nvram_sem);
+
+	//free cache
+	for (i = 0; i < MAX_CACHE_ENTRY; i++) {
+		if (fb[index].cache[i].name) {
+			kfree(fb[index].cache[i].name);
+			fb[index].cache[i].name = NULL;
+		}
+		if (fb[index].cache[i].value) {
+			kfree(fb[index].cache[i].value);
+			fb[index].cache[i].value = NULL;
+		}
+	}
+
+	mutex_unlock(&nvram_sem);
+	return 0;
+}
+
+/*
+ * return idx (0 ~ iMAX_CACHE_ENTRY)
+ * return -1 if no such value or empty cache
+ */
+static int cache_idx(int index, char *name)
+{
+	int i;
+
+	for (i = 0; i < MAX_CACHE_ENTRY; i++) {
+		if (!fb[index].cache[i].name)
+			continue;
+		if (!strcmp(name, fb[index].cache[i].name))
+			return i;
+	}
+	return -1;
+}
+
+/*
+ * Clear flash by filling 1s in data and setting a valid CRC
+ */
+int nvram_clear(int index)
+{
+	loff_t to;
+	size_t len, wlen;
+	int ret;
+	struct mtd_info *mtd;
+
+	NV_PRINT("--> nvram_clear %d\n", index);
+	NV_CHECK_INDEX(-1);
+
+	/* Clear cached entries */
+	nvram_close(index);
+
+	mutex_lock(&nvram_sem);
+
+	/* Construct all 1s env block */
+	len = fb[index].flash_max_len;
+	if (!fb[index].env) {
+		fb[index].env = kmalloc(len, GFP_KERNEL);
+		if (!fb[index].env) {
+			mutex_unlock(&nvram_sem);
+			return -ENOMEM;
+		}
+	}
+	memset(fb[index].env, 0xFF, len);
+
+	/* Calculate crc */
+	fb[index].env->crc = (unsigned long)nv_crc32(0, fb[index].env->data, len - sizeof(fb[index].env->crc));
+	NV_PRINT("CRC: 0x%x\n", fb[index].env->crc);
+
+	mtd = fb[index].mtd_dev;
+	if (IS_ERR_OR_NULL(mtd)) {
+		mutex_unlock(&nvram_sem);
+		return -ENODEV;
+	}
+
+	/* Write crc and all 0xff to flash */
+	to = fb[index].flash_offset;
+	len = fb[index].flash_max_len;
+	ret = mtd_read_modify_write_skip_bad(mtd, to, len, &wlen, (unsigned char *)&fb[index].env, NULL);
+	if (ret || (wlen != len)) {
+		NV_ERROR("Failed to write flash\n");
+		mutex_unlock(&nvram_sem);
+		return -EIO;
+	}
+
+	NV_PRINT("clear flash from 0x%x for 0x%lx bytes\n", (unsigned int)to, len);
+	fb[index].dirty = 0;
+
+	mutex_unlock(&nvram_sem);
+
+	return 0;
+}
+
+static int __nvram_commit(int index, int panic)
+{
+	loff_t to;
+	size_t len, wlen;
+	int ret, i;
+	char *p;
+	struct mtd_info *mtd;
+
+	NV_PRINT("--> nvram_commit %d\n", index);
+	NV_CHECK_INDEX(-1);
+	NV_CHECK_VALID();
+
+	mtd = fb[index].mtd_dev;
+	if (IS_ERR_OR_NULL(mtd)) {
+		return -ENODEV;
+	}
+
+	if (!fb[index].dirty) {
+		NV_PRINT("nothing to be committed\n");
+		return 0;
+	}
+
+	/* Construct env block */
+	len = fb[index].flash_max_len;
+	if (!fb[index].env) {
+		fb[index].env = kmalloc(len, panic ? GFP_ATOMIC : GFP_KERNEL);
+		if (!fb[index].env) {
+			return -ENOMEM;
+		}
+	}
+	memset(fb[index].env, 0, len);
+	p = fb[index].env->data;
+	for (i = 0; i < MAX_CACHE_ENTRY; i++) {
+		int l;
+
+		if (!fb[index].cache[i].name || !fb[index].cache[i].value)
+			continue;
+		l = strlen(fb[index].cache[i].name) + strlen(fb[index].cache[i].value) + 2;
+		if (p - fb[index].env->data + 2 >= fb[index].flash_max_len) {
+			NV_ERROR("UBOOT_ENV_SIZE 0x%x is not enough!", UBOOT_ENV_SIZE);
+			return -1;
+		}
+		snprintf(p, l, "%s=%s", fb[index].cache[i].name, fb[index].cache[i].value);
+		p += l;
+	}
+
+	*p = '\0'; //ending null
+
+	/* Calculate crc */
+	fb[index].env->crc = (unsigned long)nv_crc32(0, fb[index].env->data, len - sizeof(fb[index].env->crc));
+	NV_PRINT("%s crc:0x%x\n", __func__, fb[index].env->crc);
+
+	/* Write CRC and data to flash */
+	to = fb[index].flash_offset;
+	len = fb[index].flash_max_len;
+	if (!panic)
+		ret = mtd_read_modify_write_skip_bad(mtd, to, len, &wlen, (unsigned char *)fb[index].env, NULL);
+	else
+		ret = mtd_panic_read_modify_write_skip_bad(mtd, to, len, &wlen, (unsigned char *)fb[index].env, NULL);
+	if (ret || (wlen != len)) {
+		NV_ERROR("Failed to write CRC and data\n");
+		return -EIO;
+	}
+
+	fb[index].dirty = 0;
+
+	return 0;
+}
+
+int nvram_commit(int index)
+{
+	int ret = 0;
+
+	mutex_lock(&nvram_sem);
+	ret = __nvram_commit(index, 0);
+	mutex_unlock(&nvram_sem);
+
+	return ret;
+}
+
+int panic_nvram_commit(int index)
+{
+	int ret = 0;
+
+	ret = __nvram_commit(index, 1);
+
+	return ret;
+}
+
+static int __nvram_set(int index, char *name, char *value, int panic)
+{
+	int idx;
+
+	NV_PRINT("--> nvram_set %d %s=%s\n", index, name, value);
+	NV_CHECK_INDEX(-1);
+	NV_CHECK_VALID();
+
+	idx = cache_idx(index, name);
+
+	if (-1 == idx) {
+
+		/* Find the first empty slot */
+		for (idx = 0; idx < MAX_CACHE_ENTRY; idx++) {
+			if (!fb[index].cache[idx].name) {
+				break;
+			}
+		}
+		/* No more empty slot */
+		if (idx == MAX_CACHE_ENTRY) {
+			NV_ERROR("Run out of env cache, please increase MAX_CACHE_ENTRY\n");
+			return -1;
+		}
+		fb[index].cache[idx].name = kstrdup(name, panic ? GFP_ATOMIC : GFP_KERNEL);
+		fb[index].cache[idx].value = kstrdup(value, panic ? GFP_ATOMIC : GFP_KERNEL);
+	} else {
+		/* abandon the previous value */
+		kfree(fb[index].cache[idx].value);
+		fb[index].cache[idx].value = kstrdup(value, panic ? GFP_ATOMIC : GFP_KERNEL);
+	}
+
+	fb[index].dirty = 1;
+
+	return 0;
+}
+
+int nvram_set(int index, char *name, char *value)
+{
+	int ret;
+
+	mutex_lock(&nvram_sem);
+	ret = __nvram_set(index, name, value, 0);
+	mutex_unlock(&nvram_sem);
+
+	return ret;
+}
+
+int panic_nvram_set(int index, char *name, char *value)
+{
+	int ret;
+
+	ret = __nvram_set(index, name, value, 1);
+
+	return ret;
+}
+
+static const char *__nvram_get(int index, char *name)
+{
+	int idx;
+	const char *ret;
+
+	NV_PRINT("--> nvram_get %d %s\n", index, name);
+	NV_CHECK_INDEX(NULL);
+	NV_CHECK_VALID();
+
+	idx = cache_idx(index, name);
+	if (-1 != idx) {
+		if (fb[index].cache[idx].value) {
+			ret = fb[index].cache[idx].value;
+			return ret;
+		}
+	}
+
+	return NULL;
+}
+
+const char *nvram_get(int index, char *name)
+{
+	const char *ret;
+
+	mutex_lock(&nvram_sem);
+	ret = __nvram_get(index, name);
+	mutex_unlock(&nvram_sem);
+
+	return ret;
+}
+
+const char *panic_nvram_get(int index, char *name)
+{
+	const char *ret;
+
+	ret = __nvram_get(index, name);
+
+	return ret;
+}
+
+int nvram_getall(int index, char *buf)
+{
+	int i, len;
+	char *p;
+
+	NV_PRINT("--> nvram_getall %d\n", index);
+	NV_CHECK_INDEX(-1);
+
+	mutex_lock(&nvram_sem);
+	NV_CHECK_VALID();
+
+	len = fb[index].flash_max_len;
+	if (!fb[index].env) {
+		fb[index].env = kmalloc(len, GFP_KERNEL);
+		if (!fb[index].env)
+			return -ENOMEM;
+	}
+	memset(fb[index].env, 0, len);
+	p = buf;
+	for (i = 0; i < MAX_CACHE_ENTRY; i++) {
+		int l, ret __maybe_unused;
+
+		if (!fb[index].cache[i].name || !fb[index].cache[i].value)
+			continue;
+		l = strlen(fb[index].cache[i].name) + strlen(fb[index].cache[i].value) + 2;
+#if 0
+		if (p - fb[index].env.data + 2 >= fb[index].flash_max_len) {
+			RANV_ERROR("UBOOT_ENV_SIZE 0x%x is not enough!", UBOOT_ENV_SIZE);
+			mutex_unlock(&nvram_sem);
+			return -1;
+		}
+#endif
+		ret = snprintf(p, l, "%s=%s", fb[index].cache[i].name, fb[index].cache[i].value);
+
+		p += l;
+	}
+	*p = '\0'; //ending null
+
+	mutex_unlock(&nvram_sem);
+
+	return 0;
+}
+
+int nvram_sync(int index1, int index2)
+{
+	int i;
+//	NV_CHECK_INDEX(-1);
+
+	mutex_lock(&nvram_sem);
+//	NV_CHECK_VALID();
+	if((fb[index1].valid == 0) || (fb[index2].valid == 0)) {
+		return -1;
+	}
+
+	for (i = 0; i < MAX_CACHE_ENTRY; i++) {
+		if(!fb[index1].cache[i].name || !fb[index1].cache[i].value)
+			continue;
+		mutex_unlock(&nvram_sem);
+		nvram_set(index2, fb[index1].cache[i].name, fb[index1].cache[i].value);
+		mutex_lock(&nvram_sem);
+	}
+	mutex_unlock(&nvram_sem);
+	nvram_commit(index2);
+
+	return 0;
+}
+
+int nvram_unset(int index, char *name)
+{
+	int idx;
+
+	NV_PRINT("--> nvram_unset %d %s\n", index, name);
+
+	NV_CHECK_INDEX(-1);
+
+	mutex_lock(&nvram_sem);
+	NV_CHECK_VALID();
+
+	idx = cache_idx(index, name);
+
+	if (-1 != idx) {
+		fb[index].dirty = 1;
+		kfree(fb[index].cache[idx].name);
+		fb[index].cache[idx].name = NULL;
+		kfree(fb[index].cache[idx].value);
+		fb[index].cache[idx].value = NULL;
+	}
+
+	mutex_unlock(&nvram_sem);
+
+	return 0;
+}
+
+int nvram_reload(int index)
+{
+
+	NV_PRINT("--> nvram_reload %d\n", index);
+	NV_CHECK_INDEX(-1);
+
+	mutex_lock(&nvram_sem);
+	NV_CHECK_VALID();
+
+	fb[index].valid = 0;
+	mutex_unlock(&nvram_sem);
+	return init_nvram_block(index);
+}
+
+late_initcall(nvram_init);
+module_exit(nvram_exit);
+EXPORT_SYMBOL(nvram_get);
+EXPORT_SYMBOL(nvram_set);
+EXPORT_SYMBOL(nvram_commit);
Index: linux-4.4.60/drivers/miwifi/nvram.h
===================================================================
--- /dev/null
+++ linux-4.4.60/drivers/miwifi/nvram.h
@@ -0,0 +1,77 @@
+#ifndef _NVRAM_H
+#define _NVRAM_H 	1
+
+/* Keep this consistent with U-Boot CONFIG_ENV_SIZE */
+#define UBOOT_ENV_SIZE (64 << 10)
+
+#define FLASH_BLOCK_NUM	2
+#define UBOOT_NVRAM	0
+#define BDATA_NVRAM	1
+
+#define NVRAM_DEVNAME "nvram"
+#define NVRAM_MTDNAME "0:APPSBLENV"
+#define BDATA_MTDNAME "bdata"
+
+#define NV_PRINT(x, ...) do { if (nvram_debug) printk("\n%s %d: " x, __FILE__, __LINE__, ## __VA_ARGS__); } while(0)
+#define NV_ERROR(x, ...) do { printk("%s %d: ERROR! " x, __FILE__, __LINE__, ## __VA_ARGS__); } while(0)
+
+//x is the value returned if the check failed
+#define NV_CHECK_INDEX(x) do { \
+        if (index < 0 || index >= FLASH_BLOCK_NUM) { \
+                NV_PRINT("index(%d) is out of range\n", index); \
+		return x; \
+        } \
+} while (0)
+
+#define NV_CHECK_VALID() do { \
+        if (!fb[index].valid) { \
+                NV_PRINT("fb[%d] invalid, init again\n", index); \
+		init_nvram_block(index); \
+        } \
+} while (0)
+
+typedef struct environment_s {
+	uint32_t crc;		//CRC32 over data bytes
+	char data[UBOOT_ENV_SIZE - sizeof(uint32_t)];
+} __attribute__((packed)) env_t;
+
+typedef struct cache_environment_s {
+	char *name;
+	char *value;
+} cache_t;
+
+#define MAX_CACHE_ENTRY 500
+typedef struct block_s {
+	char *name;
+	char *mtd_name;
+	struct mtd_info *mtd_dev;
+	unsigned long flash_offset;
+	unsigned long flash_max_len;	//UBOOT_ENV_SIZE
+	env_t *env;			//env block
+	cache_t	cache[MAX_CACHE_ENTRY];	//env cache entry by entry
+
+	char valid;
+	char dirty;
+} block_t;
+
+#define MAX_NAME_LEN 128
+#define MAX_VALUE_LEN (UBOOT_ENV_SIZE >> 5)
+typedef struct nvram_ioctl_s {
+	int index;
+	int ret;
+	char *name;
+	char *value;
+} nvram_ioctl_t;
+
+#define NVRAM_IOC_MAGIC		'n'
+#define NVRAM_IOCTL_GET		_IOR(NVRAM_IOC_MAGIC, 0x01, nvram_ioctl_t *)
+#define NVRAM_IOCTL_GETALL	_IOR(NVRAM_IOC_MAGIC, 0x02, nvram_ioctl_t *)
+#define NVRAM_IOCTL_SET		_IOW(NVRAM_IOC_MAGIC, 0x03, nvram_ioctl_t *)
+#define NVRAM_IOCTL_COMMIT	_IO(NVRAM_IOC_MAGIC, 0x04)
+#define NVRAM_IOCTL_CLEAR	_IO(NVRAM_IOC_MAGIC, 0x05)
+#define NVRAM_IOCTL_SYNC	_IO(NVRAM_IOC_MAGIC, 0x06)
+#define NVRAM_IOCTL_UNSET	_IOW(NVRAM_IOC_MAGIC, 0x07, nvram_ioctl_t *)
+#define NVRAM_IOCTL_RELOAD	_IO(NVRAM_IOC_MAGIC, 0x08)
+
+
+#endif
Index: linux-4.4.60/include/misc/nvram.h
===================================================================
--- /dev/null
+++ linux-4.4.60/include/misc/nvram.h
@@ -0,0 +1,14 @@
+#ifndef __NVRAM_H__
+#define __NVRAM_H__
+
+#define UBOOT_NVRAM    0
+#define BDATA_NVRAM    1
+
+extern const char *nvram_get(int index, char *name);
+extern const char *panic_nvram_get(int index, char *name);
+extern int nvram_set(int index, char *name, char *value);
+extern int panic_nvram_set(int index, char *name, char *value);
+extern int nvram_commit(int index);
+extern int panic_nvram_commit(int index);
+extern int nvram_unset(int index, char *name);
+#endif
